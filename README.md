# autostels

# Установка

Не был указан диалект sql - выбрал postgresql. Базу можно развернуть локально с помощью _docker-compose.yml_ (для инициализации хранилища используется _init.sql_)

Мои тестовые данные также можно посмотреть в файл table.xls.

После развертывания я использовал psql утилитку для проверки своего решения.


Команда подключения. Пароль: pwd

```
psql -h localhost -p 9080 -U postgres -d stock
```

### Ограничение тестовых данных
Отсутствуют первичные и внешние ключи


# Решение

Если я верно понял условие задачи, то ее можно разбить на две части
 - необходимо правильно определить log_id при заданом моменте времени
 - по таблице LogStock определить количесто товаров использую ранее полученные log_id

Так как указан именно момент времени то предположу что условие выборки должно быть с какой-либо точностью, допустим - секунды.

~~~sql
select log_id, log_date
from log 
where log_date = to_timestamp('02-02-2003 00:21:00', 'DD-MM-YYYY HH24:mi:ss')
~~~

В таблице LogStock я не совсем понял почему именно так организовано движение товара, а именно по две (либо одной) записи. Но этом случае чтобы определить актуальное количество по заданному log_id необходимо выбрать последний элемент (при условии что первичный ключ целочисленный и нарастающий), например:


| ls_id | log_id | product_id | quantity |
| ----- | ------ | ---------- | -------- |
| 1004  | 3      | 10         | -2       |
| 1005  | 3      | 10         | **2**    |

Если я верно понял актуальное значение товара будет **2**.

Можно воспользоваться группировкой, но думаю самым простым решение по поиску количества это просто просуммировать все значения ингорирую отрицательные (это решение снимает ограничения на первыичный ключ - целочисленность/нарастание). В этом случае наличие даже одного отрицательного элемента на повлияет на общее решение.

| ls_id | log_id | product_id | quantity |
| ----- | ------ | ---------- | -------- |
| 1006  | 4      | 10         | -4       |


В целом решение может быть примерно таким

~~~sql
with log as (
  select log_id, log_date
  from log 
  where log_date = to_timestamp('02-02-2003 00:21:00', 'DD-MM-YYYY HH24:mi:ss')
)
select log.log_date, 
      logstock.product_id, 
      sum(
        case 
        when logstock.quantity < 0 then 0
           else logstock.quantity
         end 
       )
from logstock
     inner join log on logstock.log_id=log.log_id
group by log.log_date, 
         logstock.product_id;
~~~

Например для даты _02-02-2003 00:21:00_ ответ выглядит так

|      log_date       | product_id | sum |
|---------------------|------------|---- |
| 2003-02-02 00:21:00 |         20 |   9 |